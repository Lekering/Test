# Как работает Pipeline - Подробное объяснение

## Исходный код (строки 67-74)

```go
currentIn := in                    // Начальный канал (данные от генератора)
for _, c := range comand {         // Для каждой функции в pipeline
    out := make(chan any)          // Создаем НОВЫЙ выходной канал
    go c(currentIn, out)           // Запускаем функцию в горутине
    currentIn = out                // Выход становится входом для следующего этапа
}
return currentIn                   // Возвращаем последний выходной канал
```

## Схема работы Pipeline

### Пример: Pipeline(SumNumber, SecondNumber, AddConstant)

```
┌─────────────┐
│  generating │  генерирует: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9...
└──────┬──────┘
       │
       ▼
   ┌───────┐
   │  in   │  ← канал типа chan any (преобразованный)
   └───┬───┘
       │
       │ ИТЕРАЦИЯ 1: c = SumNumber
       │
       ▼
   ┌──────────────┐         ┌─────────┐
   │ currentIn    │────────▶│  out1   │  ← создан новый канал out1
   │ (изначально  │         └────┬────┘
   │  = in)       │              │
   └──────────────┘              │
        ▲                        │
        │                        ▼
        │              ┌──────────────────┐
        │              │  SumNumber       │  умножает на 2
        │              │  (горутина)      │  → 0, 2, 4, 6, 8, 10...
        │              └──────────────────┘
        │                        │
        │                        │
        └────────────────────────┘
              currentIn = out1 (теперь currentIn указывает на out1)
       
       │ ИТЕРАЦИЯ 2: c = SecondNumber
       │
       ▼
   ┌──────────────┐         ┌─────────┐
   │ currentIn    │────────▶│  out2   │  ← создан новый канал out2
   │ (теперь      │         └────┬────┘
   │  = out1)     │              │
   └──────────────┘              │
        ▲                        │
        │                        ▼
        │              ┌──────────────────┐
        │              │  SecondNumber    │  фильтрует четные
        │              │  (горутина)      │  → 0, 2, 4, 6, 8, 10...
        │              └──────────────────┘
        │                        │
        │                        │
        └────────────────────────┘
              currentIn = out2 (теперь currentIn указывает на out2)
       
       │ ИТЕРАЦИЯ 3: c = AddConstant
       │
       ▼
   ┌──────────────┐         ┌─────────┐
   │ currentIn    │────────▶│  out3   │  ← создан новый канал out3
   │ (теперь      │         └────┬────┘
   │  = out2)     │              │
   └──────────────┘              │
        ▲                        │
        │                        ▼
        │              ┌──────────────────┐
        │              │  AddConstant     │  добавляет 10
        │              │  (горутина)      │  → 10, 12, 14, 16, 18...
        │              └──────────────────┘
        │                        │
        │                        │
        └────────────────────────┘
              currentIn = out3 (теперь currentIn указывает на out3)

return currentIn  ← возвращаем out3 (последний канал)
```

## Полная схема потока данных

```
Генератор → in → SumNumber → out1 → SecondNumber → out2 → AddConstant → out3 (result)
   │          │      │          │         │           │        │           │
   │          │      │          │         │           │        │           │
   0,1,2...   0,1,2... 0,2,4...   0,2,4...   0,2,4...    0,2,4...   10,12,14... 10,12,14...
```

## Пошаговое выполнение

### Шаг 1: Инициализация
```go
currentIn := in  // currentIn указывает на канал 'in'
```

### Шаг 2: Первая итерация (SumNumber)
```go
out := make(chan any)        // Создали канал out1
go SumNumber(currentIn, out) // Запустили SumNumber с in → out1
currentIn = out              // currentIn теперь указывает на out1
```

### Шаг 3: Вторая итерация (SecondNumber)
```go
out := make(chan any)           // Создали канал out2
go SecondNumber(currentIn, out) // Запустили SecondNumber с out1 → out2
currentIn = out                 // currentIn теперь указывает на out2
```

### Шаг 4: Третья итерация (AddConstant)
```go
out := make(chan any)          // Создали канал out3
go AddConstant(currentIn, out) // Запустили AddConstant с out2 → out3
currentIn = out                // currentIn теперь указывает на out3
```

### Шаг 5: Возврат результата
```go
return currentIn  // Возвращаем out3
```

## Ключевые моменты

1. **Каждая итерация создает НОВЫЙ канал** (`out := make(chan any)`)
2. **currentIn переназначается** на выход предыдущего этапа
3. **Все функции запускаются параллельно** в горутинах (`go c(...)`)
4. **Данные текут последовательно** через цепочку каналов
5. **Последний канал возвращается** как результат pipeline

## Визуализация во времени

```
Время →
│
│  Генератор пишет в 'in'
├─────────────────────────────────────
│
│  SumNumber читает из 'in', пишет в 'out1'
├─────────────────────────────────────
│
│  SecondNumber читает из 'out1', пишет в 'out2'
├─────────────────────────────────────
│
│  AddConstant читает из 'out2', пишет в 'out3'
├─────────────────────────────────────
│
│  main() читает из 'out3' (result)
└─────────────────────────────────────
```

## Аналогия

Представьте конвейер на фабрике:
- Каждый этап (SumNumber, SecondNumber, AddConstant) - это отдельный станок
- Каналы - это ленты конвейера, соединяющие станки
- `currentIn = out` - это как переключать ленту на следующий станок
- Все станки работают одновременно (горутины), передавая продукт по конвейеру

