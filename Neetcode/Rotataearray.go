package main

// Вариант эффективнее: in-place reverse, O(n) time, O(1) space
// Функция поворачивает слайс nums на k позиций вправо. Все операции выполняются in-place.
// Описание каждого шага приведено в комментариях.
func rotate(nums []int, k int) {
	n := len(nums) // 1. Находим длину слайса

	// 2. Если слайс пустой или k делится нацело на n (ничего менять не нужно) — просто выходим
	if n == 0 || k%n == 0 {
		return
	}

	// 3. Приводим k к диапазону [0, n-1], чтобы избежать лишних циклов если k > n
	k = k % n // на случай если k > n

	// 4. Объявляем вспомогательную функцию для реверса подмассива на отрезке [l, r]
	//    Перекидываем элементы с двух концов внутрь
	reverse := func(arr []int, l, r int) {
		for l < r {
			arr[l], arr[r] = arr[r], arr[l]
			l++
			r--
		}
	}

	// 5. Сначала полностью разворачиваем весь массив:
	reverse(nums, 0, n-1)

	// 6. Затем разворачиваем первые k элементов,
	//    чтобы их порядок стал как в итоговом массиве после ротации
	reverse(nums, 0, k-1)

	// 7. В конце разворачиваем оставшиеся n-k элементов,
	//    чтобы и они оказались в правильном порядке
	reverse(nums, k, n-1)
}
